# Hail's expression language

Several Hail commands provide the ability to perform a broad array of computations based on data structures exposed to the user.  

**Supported comparisons and transformations:**

 - Conditionals: `if (p) a else b` -- The value of the conditional is the value of `a` or `b` depending on `p`.  If `p` is missing, the value of the conditional is missing.
 - Let: `let v1 = e1 and v2 = e2 and ... and vn = en in b` -- Bind variables `v1` through `vn` to result of evaluating the `ei`.  The value of the `let` is the value of `b`.  `v1` is visible in `e2` through `en`, etc.
 - Global comparisons: `a == b`, `a != b`
 - Boolean comparisons: `a || b`, `a && b`  Boolean comparisons short circuit.  If `a` is true, `a || b` is `true` without evaluating `b`.  If `a` is missing, `b` is evaluated and the comparison returns `true` if `b` is true, otherwise missing.
 - Missingness:
 
     - isMissing: `isMissing(a)` -- returns true if `a` is missing
     - isDefined: `isDefined(a)` -- returns true if `a` is defined
     - orElse: `a.OrElse(x)` -- return `a` if `a` is defined, otherwise `x`.  `x` is only evaluated if `a` is NA.
 - Numerical comparisons: `<`, `<=`, `>`, `>=`
 - Numerical conversions: 
 
     - toDouble: `i.toDouble`
     - toInt: `i.toInt`
     - toFloat: `i.toFloat`
     - toLong: `i.toLong`
 - Numerical transformations:
 
     - +, -, /, *, %: `a + b - c / d * e % f`
     - abs: `i.abs` -- returns the absolute value of `i`
     - signum: `i.signum` -- returns the sign of `i` (1, 0, or -1)
     - min: `i.min(j)` -- returns the minimum of `i` and `j`
     - max: `i.max(j)` -- returns the maximum of `i` and `j`
 - String operations: 
 
     - apply: `str(index)` -- returns the character at `index`
     - length: `str.length` -- returns the length of the string
     - concatenate: `str1 + str2` -- returns the two strings joined start-to-end
     - split: `str.split(delimiter)` -- returns an array of strings, split on the given `delimiter` 
 - String conversions:
 
    - toInt: `str.toInt`
    - toDouble: `str.toDouble`
    - toLong: `str.toLong`
    - toFloat: `str.toFloat`
 - Array Operations:
     - constructor: `[element1, element2, ...]` -- Create a new array from elements of the same type.
     - indexing: `arr[index]` -- get a value from the array, or NA if array or index is missing
     - slicing: `arr[start:end]` -- get a slice of the array (as an array).  The `start` is inclusive, the `end` is not.  For example, `[0,1,2,3,4][0:2]` returns `[0,1]`.  `[0,1,2,3,4,5][2:5]` returns `[2,3,4]`.
     - length / size: `arr.length` / `arr.size` -- returns the length of the array as an integer
     - isEmpty: `arr.isEmpty` -- returns true if the array has length 0
     - mkString: `arr.mkString(sep)` -- returns a string generated by joining elements sequentially, delimited by `sep`
     - toSet: `arr.toSet` -- returns a set of the same type (good if you need to call `.contains`, which is not available for arrays)
     - min: `arr.min` -- valid only for numeric arrays, returns the minimum value
     - max: `arr.max` -- valid only for numeric arrays, returns the minimum value
     - find: `arr.find(v => expr)` -- Returns the first non-missing element of `arr` for which `expr` is true.  If no element satisfies the predicate, `find` returns NA.
     - map: `arr.map(v => expr)` -- Returns a new array produced by applying `expr` to each element
     - filter: `arr.filter(v => expr)` -- Returns a new array subsetted to the elements where `expr` evaluated to true
     - exists: `arr.exists(v => expr)` -- Returns a boolean which is true if **any** element satisfies `expr`, false otherwise
     - forall: `arr.forall(v => expr)` -- returns a boolean which is true if the array is empty, or `expr` evaluates to `true` for **every** element
 - Set Operations: 
 
     - contains: `set.contains(elem)` -- returns true if the element is contained in the array, otherwise false
     - size: `set.size` -- returns the number of elements in the set as an integer
     - isEmpty: `set.isEmpty` -- returns true if the set contains 0 elements
     - equals: `set1 == set2` -- returns true if both sets contain the same elements
     - plus: `set1 + elem` -- adds `elem` to `set1` and returns the new set
     - minus: `set1 - elem` -- removes `elem` from `set1` (if it is present) and returns the new set
     - union: `set1.union(set2)` -- returns a new set with all elements in `set1` or `set2`
     - intersect: `set1.intersect(set2)` -- returns a new set with all elements in both `set1` and `set2`
     - diff: `set1.diff(set2)` -- returns a new set with all elements not shared between `set1` and `set2`
     - min: `set.min` -- valid only for numeric sets, returns the minimum value
     - max: `set.max` -- valid only for numeric sets, returns the minimum value
     - find: `set.find(v => expr)` -- Returns the first non-missing element of `set` for which `expr` is true.  If no element satisfies the predicate, `find` returns NA.
     - map: `set.map(v => expr)` -- Returns a new set produced by applying `expr` to each element
     - filter: `set.filter(v => expr)` -- Returns a new set subsetted to the elements where `expr` evaluated to true
     - exists: `set.exists(v => expr)` -- Returns a boolean which is true if **any** element satisfies `expr`, false otherwise
     - forall: `set.forall(v => expr)` -- returns a boolean which is true if the set is empty, or `expr` evaluates to `true` for **every** element

 - Dict Operations:
 
     - select: `dict[key]` -- returns the value keyed by the string `key`.  An example might be `global.genedict["SCN2A"]`.
     - contains: `dict.contains(key)` -- returns true if `dict` has key `key`, false otherwise.
     - mapvalues: `dict.mapvalues(x => expr)` -- returns a new dict with a transformation of the values
     - size: `dict.size` -- returns the number of key/value pairs
     - isEmpty: `dict.isEmpty` -- returns true if there is at least one key/value pairs
 
 - Struct Operations:
        
     - constructor: `{"key1": 1, "key2": "Hello", "key3": 0.99, ...}` -- Create a new struct from specified field names and values in the format shown.
     - select: `struct.field` -- returns the value of the given field of a struct.  For example, `va.info.AC` selects the struct `info` from the struct `va`, and then selects the array `AC` from the struct `info`.  
     - index: `index(Array[Struct], fieldname)` -- returns a dictionary keyed by the string field `fieldname` of the given `struct`, referencing values that are structs with the remaining fields.  
                
            For example, `global.gene_info` is the following `Array[Struct]`:
            
                 [{"PLI": 0.998, "genename": "gene1", "hits_in_exac": 1},
                 {"PLI": 0.0015, "genename": "gene2", "hits_in_exac": 10},
                 {"PLI": 0.9045, "genename": "gene3", "hits_in_exac": 2}]
            
            We can index it by gene:
            
                global.gene_dict = index(global.gene_info, genename)
            
            Now the following equality is true:
            
                global.gene_dict["gene1"] == {"PLI": 0.998, "hits_in_exac": 1}


**Note:**
 - All variables and values are case sensitive
 - Missingness propagates up.  If any element in an expression is missing, the expression will evaluate to missing.  

____

<a name="aggregables"></a>
## Aggregator functions

Hail's expression language exposes a number of 'aggregation' functions, which compute across rows or columns of the dataset.  These functions allow a user to replicate nearly all the of the statistics generated in `sampleqc` or `variantqc`, as well as compute an unrestricted set of new metrics.

These functions can be used in modules that expose `gs` as a genotype row or column aggregable, or in `annotateglobal` to aggregate over `samples` or `variants`.  

____

**Namespace of `gs`:**

Identifier | Description
:-: | ---
`v` | Variant
`va` | Variant annotations
`s` | Sample
`sa` | Sample annotations
`g` | Genotype

____

**Namespace of `samples` in `annotateglobal`:**

Identifier | Description
:-: | ---
`s` | Sample
`sa` | Sample annotations

____

**Namespace of `variants` in `annotateglobal`:**

Identifier | Description
:-: | ---
`v` | Variant
`va` | Variant annotations

### Count

```
    <aggregable>.count( <Boolean expression> )
```

`count` counts the number of occurrences for which a boolean condition evaluates to `true`.  If the condition evaluates to missing, then it is not added to the count.  

The result of `count` is a `Long` (integer).

**Examples:**

One can replicate `qc.nHet` for either samples or variants by counting:
```
    annotatesamples expr -c 'sa.nHet = gs.count(g.isHet)'
    annotatevariants expr -c 'va.nHet = gs.count(g.isHet)'
```

One can also compute more complicated counts.  Here we compute the number of non-ref cases and controls per variant (Assuming that `sa.pheno.isCase` is a boolean sample annotation)
```
    annotatevariants expr -c 'va.caseCount = gs.count(sa.pheno.isCase && g.isCalledNonRef), va.controlCount = gs.count(!(sa.pheno.isCase) && g.isCalledNonRef)'
```

Here we count the number of singleton non-ref LOFs and the number of homozygous alternate LOFs per sample, assuming that one has previously annotated variant consequence into `va.consequence`:
```
    annotatevariants expr -c 'va.isSingleton = gs.count(g.isCalledNonRef) == 1' \
    annotatesamples expr -c 'sa.singletonLOFs = gs.count(va.isSingleton && g.isCalledNonRef && va.consequence == "LOF"),
                        sa.homVarLOFs = gs.count(g.isHomVar && va.consequence == "LOF")
```

This can also be used to calculate statistics from sample/variant annotations in `annotateglobal`:
```
    annotatevariants expr -c 'va.isSingleton = gs.count(g.isCalledNonRef) == 1'
    annotatesamples expr -c 'sa.callrate = gs.fraction(g.isNotCalled)'
    annotateglobal expr -c 'global.lowQualSamples = samples.count(sa.callrate < 0.95),
                  global.totalNSingleton = variants.count(va.isSingleton)'
```

____

### Fraction

```
    <aggregable>.fraction( <Boolean expression> )
```

`fraction` computes the ratio of the number of occurrences for which a boolean condition evaluates to `true`, divided by the total number of non-missing occurrences.

The result of `fraction` is a `Double` (floating-point)

**Examples:**

One can replicate call rate, or calculate missingness:
```
    filtervariants expr --keep -c 'gs.fraction(g.isNotCalled) > 0.90'
    filtersamples expr --keep -c 'gs.fraction(g.isNotCalled) > 0.95'
```

One can also extend this thinking to compute the differential missingness at SNPs and indels:
```
    annotatesamples expr -c 'sa.SNPmissingness = gs.fraction(g.isNotCalled && v.alt.isSNP),
                        sa.indelmissingness = gs.fraction(g.isNotCalled && v.alt.isIndel)
```

### Stats

```
    <aggregable>.stats( <Numeric expression> )
```

`stats` computes six useful statistics about a numeric expression.  

The result of `stats` is a group of { mean, standard deviation, min value, max value, number nonmissing, and sum }.

**Examples:**

One can replicate the calculations in `<va / sa>.qc.gqMean` and `<va / sa>.qc.gqStDev` with the command below.  After this command, `va.gqstats.mean` is equal to the result of running `variantqc` and querying `va.qc.gqMean`, and this equivalence holds for the other values.
```
    annotatevariants expr -c 'va.gqstats = gs.stats(g.gq)'
    annotatesamples expr -c 'sa.gqstats = gs.stats(g.gq)'
```

One can use `stats` to compute statistics on annotations as well:
```
    sampleqc
    annotateglobal expr -c 'global.singletonStats = samples.stats(sa.qc.nSingleton)' 
```

### Stats If

```
    <aggregable>.statsif( <Boolean expression> , <Numeric expression> )
```

`statsif` is two conceptual operations: a filter followed by a `stats`.  The six statistics will only be computed for elements where the boolean expression evaluates to `true` (not `false` or `NA`).  This function allows one to easily compute statistics on a subset of the data.

**Examples:**

Compute gq/dp statistics stratified by genotype call:
```
    annotatevariants expr -c '
        va.homrefGQ = gs.statsif(g.isHomRef, g.gq),
        va.hetGQ = gs.statsif(g.isHet, g.gq),
        va.homvarGQ = gs.statsif(g.isHomVar, g.gq),
        va.homrefDP = gs.statsif(g.isHomRef, g.dp),
        va.hetDP = gs.statsif(g.isHet, g.dp),
        va.homvarDP = gs.statsif(g.isHomVar, g.dp)'
```

Compute statistics on number of singletons stratified by case/control:
```
    sampleqc
    annotateglobal expr -c 'global.caseSingletons = samples.statsif(sa.fam.isCase, sa.qc.nSingleton),
        global.controlSingletons = samples.statsif(!sa.fam.isCase, sa.qc.nSingleton)'

```

### Collect

```
    <aggregable>.collect( <Boolean expression> , <Any expression> )
```

`collect` is an aggregator that allows a set of elements of an aggregator to be collected into an `Array`.  For example, one can collect the list of non-ref sample IDs per variant with the following:

```
    annotatevariants expr -c 'va.hetSamples = gs.collect(g.isCalledNonRef, s)'
```

The above reads, "where the genotype is called non-reference, collect the sample id".  This returns an `Array[String]`.  If instead of `gs.collect(g.isCalledNonRef, s)` we had written `gs.collect(g.isCalled NonRef, g)`, we would have returned an `Array[Genotype]`.

### Examples

#### Filtering

Filtering requires an expression that evaluates to a boolean.

```
filtersamples expr --keep -c '"PT-1234" ~ s.id'
```


```
filtersamples expr --keep -c 'sa.qc.callRate > 0.99'
```

In the below expression, we will use a different cutoff for samples with European and non-European ancestry.  This can be done with an if/else statement.

```
filtersamples expr --keep -c 'if (sa.ancestry == "EUR") sa.qc.nSingleton < 100 else sa.qc.nSingleton < 200'
```

The below expression assumes a VDS was split from a VCF, and filters down to sites which were singletons on import.  `va.aIndex` indexes into the originally-multiallelic array `va.info.AC` with the original position of each variant.

```
filtervariants expr --keep -c 'if (va.info.AC[va.aIndex]) == 1' 
```

See documentation on [exporting to TSV](ExportTSV.md) and [programmatic annotation](ProgrammaticAnnotation.md) for more examples of what Hail's language can do.
